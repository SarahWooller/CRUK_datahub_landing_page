<!DOCTYPE html>

<html>
<head>
    <title>Infix to Prefix JS Logic Evaluator</title>
    <style>
        body { font-family: Arial, sans-serif; }
        .container { padding: 20px; }
        textarea { width: 100%; box-sizing: border-box; margin-bottom: 10px; }
        label { font-weight: bold; }
        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; cursor: pointer; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Infix Logic Evaluator</h1>
        <div>
            <label for="logic-summary-message">Enter Filter Logic Expression in Infix Notation (e.g., (Filter One OR Filter Two) AND Test Key):</label><br>
            <textarea id="logic-summary-message" rows="4" cols="60">(Filter One OR Filter Two) AND Test Key</textarea>
            <button onclick="findStudies()">Find Studies</button>
        </div>

        <p>Check the **Console** (below) for the result and debug logs.</p>
    </div>

    <script>
        // --- 1. DATA SETUP ---
        const filterList = [
            { "label": "Filter One ", "id": "A1" },
            { "label": "Filter Two", "id": "B2" },
            { "label": "Test Key ", "id": "C3" }
        ];

        const idsToStudies = {
            "A1": [101, 102, 103],
            "B2": [102, 104],
            "C3": [103, 105]
        };

        const filterNameToId = {};
        filterList.forEach(item => {
            const label = item.label.trim();
            filterNameToId[label] = item.id;
        });

        const goodKeys = new Set(Object.keys(filterNameToId));
        const operatorMap = {
            "AND": "intersection",
            "OR": "union"
        };
        const validOperators = new Set(Object.keys(operatorMap));


        // --- 2. LOGIC CONVERSION AND SECURITY ---

        /**
         * Finds the index of the rightmost top-level occurrence of the given operator.
         */
        function findTopLevelOperator(expression, operator) {
            let balance = 0;
            const opLength = operator.length;

            // Iterate backwards to find the RIGHTMOST (last) operator at balance 0
            for (let i = expression.length - 1; i >= 0; i--) {
                const char = expression[i];

                if (char === ')') {
                    balance++;
                } else if (char === '(') {
                    balance--;
                } else if (balance === 0) {
                    // Check for operator match at the current position
                    if (i >= opLength - 1 && expression.substring(i - opLength + 1, i + 1) === operator) {
                         const start = i - opLength + 1;

                        // Check if the operator is surrounded by spaces
                        const isPrecededBySpace = (start === 0 || /\s/.test(expression[start - 1]));
                        const isFollowedBySpace = (i + 1 === expression.length || /\s/.test(expression[i + 1]));

                        if (isPrecededBySpace && isFollowedBySpace) {
                            return { index: start, operator: operator };
                        }
                    }
                }
            }
            return null;
        }

        /**
         * Recursively converts an infix expression to a prefix expression. (FIXED)
         */
        function infixToPrefix(infix) {
            let expression = infix.trim();
            console.log(`[Infix-Prefix Debug] Infix call with: "${expression}"`);

            // 1. Remove unnecessary outer parentheses that enclose the whole expression
            while (expression.startsWith('(') && expression.endsWith(')')) {
                let balance = 0;
                let isFullyContained = true;

                // Check if the content inside the parentheses is fully balanced with itself (balance reaches 0 at the end).
                for (let i = 1; i < expression.length - 1; i++) {
                    if (expression[i] === '(') {
                        balance++;
                    } else if (expression[i] === ')') {
                        balance--;
                        // If balance drops below zero, the outer parenthesis set is NOT the primary group for the whole sub-expression.
                        if (balance < 0) {
                            isFullyContained = false;
                            break;
                        }
                    }
                }

                if (isFullyContained && balance === 0) {
                    // The parentheses group the entire sub-expression. Strip them.
                    expression = expression.substring(1, expression.length - 1).trim();
                } else {
                    // The parentheses are either unbalanced or needed for inner grouping. Stop stripping.
                    break;
                }
            }

            // 2. Base Case: If no operators found, it's a single operand (key)
            if (!expression.includes('AND') && !expression.includes('OR')) {
                const key = expression.trim();
                if (!goodKeys.has(key)) {
                     throw new Error(`Security failed: Invalid filter key: ${key}`);
                }
                return key;
            }

            // 3. Recursive step: Find the lowest precedence, rightmost operator at balance 0.
            const operators = ["OR", "AND"]; // Process OR first (lowest precedence)

            for (const op of operators) {
                let splitInfo = findTopLevelOperator(expression, op);

                if (splitInfo) {
                    const { index, operator } = splitInfo;
                    const left = expression.substring(0, index).trim();
                    const right = expression.substring(index + operator.length).trim();

                    // Recursively convert and format to prefix
                    const leftPrefix = infixToPrefix(left);
                    const rightPrefix = infixToPrefix(right);

                    return `${operator}(${leftPrefix}, ${rightPrefix})`;
                }
            }

            // If the code reaches here, it means the expression has operators but they were not found at the top level (e.g., bad syntax).
            throw new Error(`Infix parsing failed. Check parentheses and operators: ${expression}`);
        }

        // --- 3. LOGIC EVALUATION FUNCTIONS (Set Operations) ---

        if (!Set.prototype.intersection) {
            Set.prototype.intersection = function(otherSet) {
                const intersection = new Set();
                for (const elem of otherSet) {
                    if (this.has(elem)) {
                        intersection.add(elem);
                    }
                }
                return intersection;
            }
        }

        if (!Set.prototype.union) {
            Set.prototype.union = function(otherSet) {
                const union = new Set(this);
                for (const elem of otherSet) {
                    union.add(elem);
                }
                return union;
            }
        }

        // --- 4. RECURSIVE PREFIX PARSER ---

        function parsePrefixExpression(expression) {
            expression = expression.trim();

            if (!expression.includes('(')) {
                const studies = idsToStudies[filterNameToId[expression]];
                return `new Set([${(studies || []).join(', ')}])`;
            }

            const match = expression.match(/^([A-Z]+)\s*\((.*)\)$/);
            const operator = match[1];
            const argsString = match[2];
            const jsMethod = operatorMap[operator];

            const args = [];
            let balance = 0;
            let currentArg = '';

            for (let i = 0; i < argsString.length; i++) {
                const char = argsString[i];

                if (char === '(') {
                    balance++;
                } else if (char === ')') {
                    balance--;
                } else if (char === ',' && balance === 0) {
                    args.push(currentArg.trim());
                    currentArg = '';
                    continue;
                }
                currentArg += char;
            }
            if (currentArg.trim()) {
                args.push(currentArg.trim());
            }

            const initialSet = parsePrefixExpression(args[0]);
            let finalExpression = initialSet;

            for (let i = 1; i < args.length; i++) {
                const nextSet = parsePrefixExpression(args[i]);
                finalExpression = `(${finalExpression}).${jsMethod}(${nextSet})`;
            }

            return finalExpression;
        }

        // --- 5. EXECUTION FUNCTION ---

        function findStudies() {
            const expressionText = document.getElementById('logic-summary-message').value;
            console.clear();
            console.log("--- Starting Study Search (Infix Input) ---");
            console.log("Input Infix Expression:", expressionText); // Log Infix

            if (!expressionText) {
                console.error("Please enter a filter logic expression.");
                return;
            }

            try {
                // 1. Convert Infix to Prefix
                const prefixExpression = infixToPrefix(expressionText);

                console.log("Intermediate Prefix Expression:", prefixExpression); // Log Prefix

                // 2. Convert Prefix to final executable JavaScript Set expression
                const finalExpression = parsePrefixExpression(prefixExpression);

                console.log("Intermediate JS Set Expression:", finalExpression);

                // 3. Evaluate the JS expression string to get the final Set
                const finalStudiesSet = eval(finalExpression);

                // 4. Print the result
                if (finalStudiesSet instanceof Set) {
                    const studyArray = Array.from(finalStudiesSet).sort((a, b) => a - b);
                    console.log("\n✅ Final Studies Found:");
                    console.log(studyArray);
                    console.log(`Total Studies: ${studyArray.length}`);
                } else {
                    console.error("Evaluation failed to produce a Set.");
                }

            } catch (error) {
                console.error("\n❌ An error occurred during evaluation:", error.message);
            }
            console.log("\n--- Study Search Complete ---");
        }

        document.addEventListener('DOMContentLoaded', findStudies);
    </script>

</body>
</html>